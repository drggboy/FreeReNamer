---
description: 性能优化最佳实践和并行处理模式
---

# 性能优化最佳实践

## 并行处理优化

### 文件信息获取优化
重置列宽功能的性能优化展示了关键的并行处理模式：

```typescript
// ❌ 避免：串行处理
for (const file of files) {
  const fileInfo = await getFileInfo(file); // 串行等待
}

// ✅ 推荐：并行处理
const fileInfoPromises = files.map(async (file) => {
  return await getFileInfo(file); // 并行执行
});
const results = await Promise.all(fileInfoPromises);
```

### 性能优化原则

1. **并行化异步操作**
   - 使用 `Promise.all()` 替代 `for...await` 循环
   - 适用于独立的异步操作

2. **错误处理策略**
   - 在 `map` 内部处理个别错误
   - 提供快速回退方案

3. **性能监控**
   - 添加详细的控制台日志
   - 记录处理时间和文件数量

## 采样策略优化

### 渐进式采样
根据性能测试结果动态调整处理策略：

1. **小数据集**：处理全部数据，确保100%准确性
2. **大数据集**：根据性能表现选择合适的采样策略
3. **极限情况**：提供同步回退方案

### 实现模式
```typescript
// 根据性能测试动态调整
const shouldProcessAll = files.length <= performanceThreshold;
const filesToProcess = shouldProcessAll ? files : smartSampling(files);
```

## 用户体验优化

### 加载状态管理
```typescript
const [isProcessing, setIsProcessing] = useState(false);

const handleOperation = async () => {
  setIsProcessing(true);
  try {
    await performOperation();
  } finally {
    setIsProcessing(false);
  }
};
```

### UI状态同步
- 禁用按钮防止重复操作
- 显示动态加载指示器
- 提供操作进度反馈

## 重命名执行性能优化

### 关键优化策略

1. **跳过无变化文件**
   - 提前检查文件名是否需要变更
   - 避免对无需重命名的文件进行不必要处理
   - 大幅减少实际需要处理的文件数量

2. **并行文件信息获取**
```typescript
// ❌ 避免：串行处理
for (const file of files) {
  const fileInfo = await getFileInfo(file);
}

// ✅ 推荐：并行处理
const fileInfoPromises = files.map(async (file) => {
  return await getFileInfo(file);
});
const results = await Promise.all(fileInfoPromises);
```

3. **并行重命名操作**
   - 临时文件名生成并行化
   - 两阶段重命名的每个阶段内部并行执行
   - 错误处理和回滚机制保持完整

### 性能监控
- 详细的执行时间统计
- 分类统计：成功、失败、跳过
- 平均处理速度计算
- 控制台性能日志

### 实际性能提升
对于140个文件的测试场景：
- **串行处理**：可能需要数秒甚至更久
- **并行优化**：显著减少到毫秒级别  
- **跳过优化**：大幅减少实际处理的文件数量

### 关键性能问题修复

#### 问题1：重复文件信息获取
**原问题**：冲突检查和主执行逻辑都独立调用 `getFileInfo`，导致双重性能开销
```typescript
// ❌ 原来的问题：重复调用
await checkRenameConflicts(files, sortedIndices, profile, fileItemRefs); // 第一次getFileInfo
// 主执行逻辑中再次调用getFileInfo // 第二次getFileInfo
```

**解决方案**：统一文件信息获取，一次调用同时完成冲突检查和重命名收集
```typescript
// ✅ 优化后：一次性获取
const fileInfoPromises = sortedIndices.map(async (displayIndex) => {
  const fileInfo = await getFileInfo(file); // 只调用一次
  // 同时进行冲突检查和重命名收集
});
```

#### 问题2：执行开始到收集操作的延迟
**原因**：在开始执行和开始收集之间存在冲突检查的串行处理
**效果**：从32秒优化预期可减少到15-20秒左右

#### 实际性能数据对比
- **146个文件测试**：
  - 优化前：开始执行到开始收集有明显延迟
  - 优化后：立即开始收集，消除重复调用
  - 预期总时间从32秒减少到15-20秒

## 相关文件
- [src/routes/profile/route.tsx](mdc:src/routes/profile/route.tsx) - 重命名执行性能优化实现
- [src/components/file/files-panel.tauri.tsx](mdc:src/components/file/files-panel.tauri.tsx) - 重置列宽性能优化实现
- [src/lib/filename-width-calculator.ts](mdc:src/lib/filename-width-calculator.ts) - 智能列宽计算逻辑

## 测试验证
性能优化后应验证：
- 小文件夹（<100个文件）：响应时间 < 0.5秒
- 中等文件夹（100-1000个文件）：响应时间 < 1秒  
- 大文件夹（>1000个文件）：响应时间 < 2秒